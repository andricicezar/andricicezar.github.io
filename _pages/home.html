---
layout: home
author_profile: true
permalink: /
---


<p>I’m a Ph.D. candidate at <a href="https://mpi-sp.org">MPI-SP</a>, Bochum, Germany working with <a href="https://catalin-hritcu.github.io/">Cătălin Hriţcu</a>.
My Ph.D. project is about secure interoperability between verified F* programs and unverified ML code.</p>

<h3 class="archive__subtitle">Interests</h3>

<p>
    <strong>Verification of effectful code.</strong>
    In a pure dependently-typed language, like Rocq or F*, one can write pure terminating computations and verify them.
    If one wants to write effectful computations (e.g., with state, non-termination, input/output (IO), etc.),
    then one has to give a representation to those computations. One common way is to do a shallow embedding, 
    by embedding the effect in the language using a monad.
    F* has this idea at its core and uses a construction called the Dijkstra monad.
    Such constructions were used successfully to verify big developments and realistic projects.
    My work in this space was involved into finding the pre-conditional effect (specific to F*),
    and building Dijkstra monads for terminating/non-terminating IO and Monotonic State.
    These results are useful because the effects F* supports out of the box,
    do not have a monadic representation, and my hope is that one would be able to find one
    for all of them.
    Right now, I am interested in finding a Dijkstra monad for the effects Div, Ghost, 
    Monotonic State with higher-order stores and Concurrency with IO.
</p>

<p>
    <strong>Minimizing the Trusted Computing Base (TCB) of F*.</strong>
    The language F* was used successfully in the verification of some big
    projects, some of them milestones in the verification community.
    One of the big features of F* is that it is easy to have primitive
    extraction for effectful computations to OCaml, meaning that the monadic representation
    of the computation is erased during extraction and the monad's operations are replaced
    with the corresponding OCaml operations.
    This extraction, however, it is part of the TCB of F* so it cannot be trusted to be correct.
    Moreover, if the verified extracted code gets linked to unverified code, then the chance
    that there is a bug, or an attack, is even bigger, so it may be even insecure (the logical
    invariants proved about the verified code are broken by the unverified code).
    To bring some trust to this, my work proposes SCIO* and SecRef*,
    two secure compilation frameworks for verification of IO programs, and respectively stateful programs,
    that can be safely linked with unverified code. The long-term goal of the project
    is to have secure interoperability between F* and OCaml.
    Another idea I am interested in, is to also explore if one could give up on the effect system of F*
    and instead use the typing abstractions provided by the module system.
</p>
